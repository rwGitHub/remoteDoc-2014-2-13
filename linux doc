//TODO ...
﻿http://ishare.iask.sina.com.cn/f/23237964.html

http://download.csdn.net/tag/GOF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%8C%E8%AF%AD%E7%89%88

http://ishare.iask.sina.com.cn/f/16850580.html

http://applet.sqt.orientaltele.com

sudo dmidecode  | grep CPU

sudo more /proc/cpuinfo | grep -i "cpu cores"

more /proc/cpuinfo | grep -i "cache size"

回到之前的branch
git reset --hard 10fef83da8c850f112267de78ad41f5eed9a766d

git reset --hard HEAD~2                   # 取消当前版本之前的两次提交
git push origin HEAD --force              # 强制提交到远程版本库，从而删除之前的两次提交数据

cp /etc/skel/.[a-z]* /home/xx/

===================================================================
查看应用的数据
adb shell
run-as com.yourapp
cd /data/data/com.yourapp
ls -l

===================================================================
//练习git usages
git remote add origin git@192.168.1.202:et/android/testPro.git


创建远程仓库
cd 工程目录
git init 
cd .git目录，接着编辑config
git remote add origin git@192.168.1.202:et/android/EtT2fCredit.git
git fetch

======================================================================
T2F
git clone git@192.168.1.202:et/android/EtBase.git
git clone git@192.168.1.202:et/android/EtBaseUi.git
git clone git@192.168.1.202:et/android/EtPluginCountry.git
git clone git@192.168.1.202:et/android/EtT2f.git

查看远程引用
git show-ref


git log -p 
git log -p src/com/ot24/t2flib/MyBuildConfig.java


==========================================================================
	git clone git@192.168.1.202:et/android/EtBase.git && git clone git@192.168.1.202:et/android/EtBaseUi.git && git clone git@192.168.1.202:et/android/EtCall.git && git clone git@192.168.1.202:et/android/EtCallSimple.git


<?xml version="1.0" encoding="UTF-8"?>
<classpath>
	<classpathentry kind="src" path="src"/>
	<classpathentry kind="src" path="gen"/>
	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
	<classpathentry kind="output" path="bin/classes"/>
</classpath>


连接m2 的方法
拨号模式下输入 *#*#717717#*#* 即可.

用完了再重复即可关闭



一个奶粉都造不好的国家会有崛起一个文字都会敏感的国家会有复兴一个鼠标都能摇塌的国家会有伟大一个说话都能判刑的国家会有法律一个权利都被代表的国家会有公平一个一生都遭搜刮的国家会有保障一个全部污染的国家会有明天一个举国都是跪拜的国家会有未来

不见外敌入秦川，阿房大火映咸阳
御敌无方，扰民有术
民不加赋而国用饶
轻家国而重乡土

天变不足畏，祖宗不足法，人言不足恤。

str,repr和反引号是将python值转为字符串的三种方法。ps :事实上，str和int,long一样，是一种类型。而repr仅仅是函数。


adb -s 7a2718d0 uninstall com.ot24.t2f && adb -s 7a2718d0 install EtT2fNormal_wx_test.apk && rm EtT2fNormal_wx_test.apk

静态检查
lint --check UnusedResources --html 要保存的路径/文件名 要检测的工程目录 
lint --check UnusedResources --html /home/renwei/playground/Ett2fnormal.html ~/android/workspace/EtT2f

  cd /lib/
ls
cd x86_64-linux-gnu/
strings libc-2.15.so 
strings libc-2.15.so | grep GLIBC
history

=======================================================================================================================================================
=======================================================================================================================================================

谚语：：：
Poverty is no sin. [谚语]贫非罪。
Poverty is not a shame, but being ashamed of it is. [谚语]贫非耻，耻贫乃耻。
Poverty makes (或acquaints men with) strange bedfellows. [谚语]同病相怜；难中不择友。
Since this is so,it's better to accept it. 
既来之，则安之。
It never rains but it pours.
[谚语]不雨则已，一雨倾盆(指事情不发生则已，一旦发生便接踵而来)。
God tempers the wind to the shorn lamb. [谚语]上帝对不幸的人是宽厚的
Blood is thicker than water.
血浓于水.
Charity begins at home.
仁爱始于家.
A person should help his family or close friends before helping others.
人应该先帮助家人和密友，然后再帮助其他人。
He who would climb a ladder must begin at the bottom.
千里之行始于足下.
Tell me who walks with you, and I'll tell you who you are.
观其友知其人.
It does not matter the speed you go. The most important thing is to never stop.
重要的不是速度，而是永不放弃。
Think twice, act wise.
三思而后行.
Practice makes perfect.
熟能生巧.
If you want something done right, do it yourself.
自己动手，丰衣足食。
If you risk nothing, then you risk everything.
万事不冒险将一事无成
Your defeat now is your victory in the future.
失败是成功之母。
Where there is a will ,there is a way.
有志者，事竟成.
Strike while the iron is hot.
趁热打铁.
God helps those who help themselves.
自助者天助.
Birds of a feather flock together.
物以类聚
Who stole the donkey? [对破不了案警察的嘲讽语]究竟谁偷了驴子?
People often say that money talks.
人们常说有钱能使鬼推磨。
You can talk.
[口语]
亏你还说别人。
(别担心)你能行。
You can't talk. [口语]你没资格说别人。你也一样坏。
That's the talk! [美国口语]不错!正是这样!
talk wet [俚语]胡诌，瞎扯，乱弹琴
[澳大利亚英语][the wet](澳大利亚中部或北部的)雨季
Agree, for the law is costly. [谚语]和解好，官司代价高。
Some people often worry about what they will do in a situation that might happen in the future.
有些人常常为如何应对未来可能发生的情况而忧心。
Don't cross that bridge until you come to it.
船到桥头自然直.
It is usually much better to prevent a problem from happening than it is to find ways to solve it.
在开始前就预防问题发生总比发生后想办法解决问题好得多。
an ounce of prevention is worth a pound of cure.
预防为主，治疗为辅。
You can catch more flies with honey than with vinegar.
用蜜比用醋能捉到更多的苍蝇。
 That sounds fine with me
可以。
What do they do?
她们是干什么的？
Two blacks do not make a white. [谚语]两邪不等于一正。(或：两个错误不等于一个正确。)
The die is cast(或thrown). [谚语]木已成舟。(事成定局，不可更改，无法挽回)
Opportunity knocks (at the door)only once. [谚语]机不可失，时不再来。
Laurence bids wages. [谚语]夏日炎热，什么事都懒得做。
Out of debt, out of danger. [谚语]无债一身轻。
He that dies pays all debts. [谚语]一死了百债。
Debt is the worst poverty. [谚语]贫穷莫过于负债。
'You might drive behind somebody that is driving slow and be angry because they're old.
在一个开车很慢的人后面开车你可能会生气，因为他们老了。




1.3 chapter:
For some people, not knowing what you are getting is part of the fun. It’s like
opening a birthday gift.
If you’re looking for the convenience of shrink-wrapped software that just installs and runs,
there are open source projects for you—just not as many.

1.3.2
you won’t know what you’re getting into. 无所适从

1.4.1
people follow some intuitive file-naming conventions, and the file-
name does a good job of identifying the archive type
人们遵循一些直观的文件名命名规则，文件名就能较好的反映出它的归档类型。

1.4.2
Archive files keep track of the files they contain with a table of contents.
归档文件用一个目录表记录着其所包含的文件。

.tar tar archive, uncompressed
.tar.gz .tgz tar archive, compressed with gzip
.tar.bz2 tar archive, compressed with bzip2
.tar.Z .taz tar archive, compressed with the UNIX compress command


tar tar -tvf filename
tar archive compressed with gzip tar -tzvf filename
tar archive compressed with bzip tar -tjvf filename

file 文件名
file -z 文件名

1.5.1
Most often, binaries are available in a package format and less frequently in tar
archive format.
通常，二进制格式适用于软件包格式，很少用于tar归档文件。

1.6.0
Don't assume that you are not a target. 不要想当然的认为自己不会成为被攻击的对象。

1.6.1
With security, it’s not just what you run, but also when you run it. 安全性不仅仅所运行的程序本身，也包含运行过程的安全。

1.6.2
Anything else will cause it to complain.Who stole the donkey? [对破不了案警察的嘲讽语]究竟谁偷了驴子? 否则就会引起错误。


1.7 之前
Simply trying to build an unfamiliar project can become a time vacuum as you search for all
the required development packages。 翻译不通

These are the scripts that pose the most immediate danger。脚本造成最直接的危害

You install the package and cross your fingers as to whether
it’s going to work. 翻译不通

1.7.0
The textual information that comes with a package varies from one format to the
next. 软件包的文本信息因格式不同而不同。

This may be names of other packages or names of executable programs that the package requires. 翻译不通。

1.7.3
ar -t cron_3.0pl1-72_i386.deb 检查软件包文件
ar -x filename.deb  解压软件包

现在可以直接压缩和解压了:
tar -Jcvf etc.tar.xz /etc
tar -Jxf etc.tar.xz

tar常见文件解压法：
　　　　.gz - z 小写；
　　　　.bz2 - j 小写；
　　　　.xz - J 大写；
　　　　.Z - Z大写；

1.9.0
I looked at some of the tools that are built on top of the packaging tools.
介绍了一些建立在打包工具之上的工具。

概述：
dpkg , gpg,gzip, bzip2, tar, ar .

============================================================================================================
chapter 2
============================================================================================================

2.1
工具：make .
2.2.1
The simplicity of make is both a feature and a drawback.
make 的精简既是它的有点也是它的不足。

And they feel that unknown dangers in the business world threaten the survival of their business. survival 的用法貌似有问题。

书：1，隐藏的心理学
书籍推荐：《侧写师——用犯罪心理学破解微表情密码》

pseudotarget 不是很理解。
whatis 命令， 查找man 页。
apropos and whatis 两个命令搜索man手册页。
spike would work 。 秒杀
Well met 。 幸会幸会
an order for medicine. 处方药。
3.2.5
man 手册各个部分
SEE ALSO
ENVIRONMENT
CONFORMING TO
BUGS
===========================
whatis intro 
selections
==================
ascii 
boot 
bootparam 
charsets 
hier 
man 
operator 
regex 
suffixes 
units 
uri
url
urn
3.2.7
=================
info 文档化所有工具
troff
nroff
==================
3.2.8
If you type info info, you get information about the info format, not the info program.
you have to type info info-stnd, which will give you the correct documentation.
info "(make)Quick Reference" 精确查找info页
info --subnodes some-topic | less 像man 一样查看命令

info --apropos 命名 搜索结果较apropos 更中肯
Each info file has an index, which can be searched with the --apropos option, so
your search is more likely to produce output with info than with the apropos
command used for man pages

info also has a -w option that behaves like the whereis command.
=================================
info pages:
coreutils 
cpp 
gcc 
ld 
libc 
=================================
GNOME’s help system is provided by the gnome-help command(also known as yelp) .
yelp is smart enough to find files in the current working directory.

Many complex tools and servers are documented by more than one man page, and these elements are cross referenced in
the SEE ALSO section. 
3.3.3 终止了，开始学习computer network written by andrew S, david.

export PATH=$HOME/android/sdk/tools:$HOME/android/sdk/platform-tools:$HOME/android/NDK:$PATH

env //打印所有的环境变量  
echo $PATH //打印PATH环境变量  
ls -1 -F | grep -v [/$] 仅显示所有文件
ls -l | grep ^d 仅所有目录

搜索
----
whereis <程序名称>
查找软件的安装路径
-b 只查找二进制文件
-m 只查找帮助文件
-s 只查找源代码
-u 排除指定类型文件
-f 只显示文件名
-B <目录> 在指定目录下查找二进制文件
-M <目录> 在指定目录下查找帮助文件
-S <目录> 在指定目录下查找源代码

locate <文件名称>
在文件索引数据库中搜索文件
-d <数据库路径> 搜索指定数据库
updatedb
更新文件索引数据库


find [路径] <表达式>
查找文件
-name <表达式> 根据文件名查找文件
-iname <表达式> 根据文件名查找文件，忽略大小写
-path <表达式> 根据路径查找文件
-ipath <表达式> 根据路径查找文件，忽略大小写
-amin <分钟> 过去N分钟内访问过的文件
-atime <天数> 过去N天内访问过的文件
-cmin <分钟> 过去N分钟内修改过的文件
-ctime <天数> 过去N天内修改过的文件
-anewer <参照文件> 比参照文件更晚被读取过的文件
-cnewer <参照文件> 比参照文件更晚被修改过的文件
-size <大小> 根据文件大小查找文件，单位b c w k M G
-type <文件类型> 根据文件类型查找文件。b 块设备 c 字符设备 d 目录 p 管道文件 f 普通文件 l 链接 s 端口文件
-user <用户名> 按归属用户查找文件
-uid <uid> 按UID查找文件
-group <群组名> 按归属群组查找文件
-gid <gid> 按GID查找文件
-empty 查找空文件


grep <字符串>|"<正则表达式>" [文件名]
在文件中搜索内容

各种文件类型解压缩：
.tar
解包：tar xvf FileName.tar
打包：tar cvf FileName.tar DirName
（注：tar是打包，不是压缩！）
---------------------------------------------
.gz
解压1：gunzip FileName.gz
解压2：gzip -d FileName.gz
压缩：gzip FileName
.tar.gz 和 .tgz
解压：tar zxvf FileName.tar.gz
压缩：tar zcvf FileName.tar.gz DirName
---------------------------------------------
.bz2
解压1：bzip2 -d FileName.bz2
解压2：bunzip2 FileName.bz2
压缩： bzip2 -z FileName
.tar.bz2
解压：tar jxvf FileName.tar.bz2
压缩：tar jcvf FileName.tar.bz2 DirName
---------------------------------------------
.bz
解压1：bzip2 -d FileName.bz
解压2：bunzip2 FileName.bz
压缩：未知
.tar.bz
解压：tar jxvf FileName.tar.bz
压缩：未知
---------------------------------------------
.Z
解压：uncompress FileName.Z
压缩：compress FileName
.tar.Z
解压：tar Zxvf FileName.tar.Z
压缩：tar Zcvf FileName.tar.Z DirName
---------------------------------------------
.zip
解压：unzip FileName.zip
压缩：zip FileName.zip DirName
---------------------------------------------
.rar
解压：rar x FileName.rar
压缩：rar a FileName.rar DirName

rar请到：http://www.rarsoft.com/download.htm 下载！
解压后请将rar_static拷贝到/usr/bin目录（其他由$PATH环境变量指定的目录也可以）：
[root@www2 tmp]# cp rar_static /usr/bin/rar
---------------------------------------------
.lha
解压：lha -e FileName.lha
压缩：lha -a FileName.lha FileName

lha请到：http://www.infor.kanazawa-it.ac.jp/~ishii/lhaunix/下载！
>解压后请将lha拷贝到/usr/bin目录（其他由$PATH环境变量指定的目录也可以）：
[root@www2 tmp]# cp lha /usr/bin/
---------------------------------------------
.rpm
解包：rpm2cpio FileName.rpm | cpio -div
---------------------------------------------
.deb
解包：ar p FileName.deb data.tar.gz | tar zxf -
---------------------------------------------
.tar .tgz .tar.gz .tar.Z .tar.bz .tar.bz2 .zip .cpio .rpm .deb .slp .arj .rar .ace .lha .lzh .lzx .lzs .arc .sda .sfx .lnx .zoo .cab .kar .cpt .pit .sit .sea
解压：sEx x FileName.*
压缩：sEx a FileName.* FileName

Linux Filesystem Hierarchy:
Prev	Chapter 1. Linux Filesystem Hierarchy	Next
1.1. Foreward

When migrating from another operating system such as Microsoft Windows to another; one thing that will profoundly affect the end user greatly will be the differences between the filesystems.

What are filesystems?

A filesystem is the methods and data structures that an operating system uses to keep track of files on a disk or partition; that is, the way the files are organized on the disk. The word is also used to refer to a partition or disk that is used to store the files or the type of the filesystem. Thus, one might say I have two filesystems meaning one has two partitions on which one stores files, or that one is using the extended filesystem, meaning the type of the filesystem.

The difference between a disk or partition and the filesystem it contains is important. A few programs (including, reasonably enough, programs that create filesystems) operate directly on the raw sectors of a disk or partition; if there is an existing file system there it will be destroyed or seriously corrupted. Most programs operate on a filesystem, and therefore won't work on a partition that doesn't contain one (or that contains one of the wrong type).


Before a partition or disk can be used as a filesystem, it needs to be initialized, and the bookkeeping data structures need to be written to the disk. This process is called making a filesystem.

Most UNIX filesystem types have a similar general structure, although the exact details vary quite a bit. The central concepts are superblock, inode, data block, directory block, and indirection block. The superblock contains information about the filesystem as a whole, such as its size (the exact information here depends on the filesystem). An inode contains all information about a file, except its name. The name is stored in the directory, together with the number of the inode. A directory entry consists of a filename and the number of the inode which represents the file. The inode contains the numbers of several data blocks, which are used to store the data in the file. There is space only for a few data block numbers in the inode, however, and if more are needed, more space for pointers to the data blocks is allocated dynamically. These dynamically allocated blocks are indirect blocks; the name indicates that in order to find the data block, one has to find its number in the indirect block first.


Like UNIX, Linux chooses to have a single hierarchical directory structure. Everything starts from the root directory, represented by /, and then expands into sub-directories instead of having so-called 'drives'. In the Windows environment, one may put one's files almost anywhere: on C drive, D drive, E drive etc. Such a file system is called a hierarchical structure and is managed by the programs themselves (program directories), not by the operating system. On the other hand, Linux sorts directories descending from the root directory / according to their importance to the boot process.


If you're wondering why Linux uses the frontslash / instead of the backslash \ as in Windows it's because it's simply following the UNIX tradition. Linux, like Unix also chooses to be case sensitive. What this means is that the case, whether in capitals or not, of the characters becomes very important. So this is not the same as THIS. This feature accounts for a fairly large proportion of problems for new users especially during file transfer operations whether it may be via removable disk media such as floppy disk or over the wire by way of FTP.


The filesystem order is specific to the function of a file and not to its program context (the majority of Linux filesystems are 'Second Extended File Systems', short 'EXT2' (aka 'ext2fs' or 'extfs2') or are themselves subsets of this filesystem such as ext3 and Reiserfs). It is within this filesystem that the operating system determines into which directories programs store their files.


If you install a program in Windows, it usually stores most of its files in its own directory structure. A help file for instance may be in C:\Program Files\[program name]\ or in C:\Program Files\[program-name]\help or in C:\Program Files\[program -name]\humpty\dumpty\doo. In Linux, programs put their documentation into /usr/share/doc/[program-name], man(ual) pages into /usr/share/man/man[1-9] and info pages into /usr/share/info. They are merged into and with the system hierarchy.


As all Linux users know, unless you mount a partition or a device, the system does not know of the existence of that partition or device. This might not appear to be the easiest way to provide access to your partitions or devices, however it offers the advantage of far greater flexibility when compared to other operating systems. This kind of layout, known as the unified filesystem, does offer several advantages over the approach that Windows uses. Let's take the example of the /usr directory. This sub-directory of the root directory contains most of the system executables. With the Linux filesystem, you can choose to mount it off another partition or even off another machine over the network using an innumerable set of protocols such as NFS (Sun), Coda (CMU) or AFS (IBM). The underlying system will not and need not know the difference. The presence of the /usr directory is completely transparent. It appears to be a local directory that is part of the local directory structure.

Compliance requires that:


 +---------+-----------------+-------------+
 |         | shareable       | unshareable |
 +---------+-----------------+-------------+
 |static   | /usr            | /etc        |
 |         | /opt            | /boot       |
 +---------+-----------------+-------------+
 |variable | /var/mail       | /var/run    |
 |         | /var/spool/news | /var/lock   |
 +---------+-----------------+-------------+

 "Shareable" files are defined as those that can be stored on one host and
 used on others. "Unshareable" files are those that are not shareable. For
 example, the files in user home directories are shareable whereas device
 lock files are not. "Static" files include binaries, libraries,
 documentation files and other files that do not change without system
 administrator intervention. "Variable" files are defined as files that
 are not static.
 

Another reason for this unified filesystem is that Linux caches a lot of disk accesses using system memory while it is running to accelerate these processes. It is therefore vitally important that these buffers are flushed (get their content written to disk), before the system closes down. Otherwise files are left in an undetermined state which is of course a very bad thing. Flushing is achieved by 'unmounting' the partitions during proper system shutdown. In other words, don't switch your system off while it's running! You may get away with it quite often, since the Linux file system is very robust, but you may also wreak havoc upon important files. Just hit ctrl-alt-del or use the proper commands (e.g. shutdown, poweroff, init 0). This will shut down the system in a decent way which will thus, guarantee the integrity of your files.


Many of us in the Linux community have come to take for granted the existence of excellent books and documents about Linux, an example being those produced by the Linux Documentation Project. We are used to having various packages taken from different sources such as Linux FTP sites and distribution CD-ROMs integrate together smoothly. We have come to accept that we all know where critical files like mount can be found on any machine running Linux. We also take for granted CD-ROM based distributions that can be run directly from the CD and which consume only a small amount of physical hard disk or a RAM disk for some variable files like /etc/passwd, etc. This has not always been the case.


During the adolescent years of Linux during the early to mid-90s each distributor had his own favorite scheme for locating files in the directory hierarchy. Unfortunately, this caused many problems. The Linux File System Structure is a document, which was created to help end this anarchy. Often the group, which creates this document or the document itself, is referred to as the FSSTND. This is short for file system standard". This document has helped to standardize the layout of file systems on Linux systems everywhere. Since the original release of the standard, most distributors have adopted it in whole or in part, much to the benefit of all Linux users.

Since the first draft of the standard, the FSSTND project has been coordinated by Daniel Quinlan and development of this standard has been through consensus by a group of developers and Linux enthusiasts. The FSSTND group set out to accomplish a number of specific goals. The first goal was to solve a number of problems that existed with the current distributions at the time. Back then, it was not possible to have a shareable /usr partition, there was no clear distinction between /bin and /usr/bin, it was not possible to set up a diskless workstation, and there was just general confusion about what files went where. The second goal was to ensure the continuation of some reasonable compatibility with the de-facto standards already in use in Linux and other UNIX-like operating systems. Finally, the standard had to gain widespread approval by the developers, distributors, and users within the Linux community. Without such support, the standard would be pointless, becoming just another way of laying out the file system.

Fortunately, the FSSTND has succeeded though there are also some goals that the FSSTND project did not set out to achieve. The FSSTND does not try to emulate the scheme of any specific commercial UNIX operating system (e.g. SunOS, AIX, etc.) Furthermore, for many of the files covered by the FSSTND, the standard does not dictate whether the files should be present, merely where the files should be if they are present. Finally, for most files, the FSSTND does not attempt to dictate the format of the contents of the files. (There are some specific exceptions when several different packages may need to know the file formats to work together properly. For example, lock files that contain the process ID of the process holding the lock.) The overall objective was to establish the location where common files could be found, if they existed on a particular machine. The FSSTND project began in early August 1993. Since then, there have been a number of public revisions of this document. The latest, v2.3 was released on January 29, 2004.

If you're asking "What's the purpose of all this? Well, the answer depends on who you are. If you are a Linux user, and you don't administrate your own system then the FSSTND ensures that you will be able to find programs where you'd expect them to be if you've already had experience on another Linux machine. It also ensures that any documentation you may have makes sense. Furthermore, if you've already had some experience with Unix before, then the FSSTND shouldn't be too different from what you're currently using, with a few exceptions. Perhaps the most important thing is that the development of a standard brings Linux to a level of maturity authors and commercial application developers feel they can support.

If you administer your own machine then you gain all the benefits of the FSSTND mentioned above. You may also feel more secure in the ability of others to provide support for you, should you have a problem. Furthermore, periodic upgrades to your system are theoretically easier. Since there is an agreed-upon standard for the locations of files, package maintainers can provide instructions for upgrading that will not leave extra, older files lying around your system inhabiting valuable disk space. The FSSTND also means that there is more support from those providing source code packages for you to compile and install yourself. The provider knows, for example, where the executable for sed is to be found on a Linux machine and can use that in his installation scripts or Makefiles.

If you run a large network, the FSSTND may ease many of your NFS headaches, since it specifically addresses the problems which formerly made shared implementations of /usr impractical. If you are a distributor, then you will be affected most by the Linux FSSTND. You may have to do a little extra work to make sure that your distribution is FSSTND-compliant, but your users (and hence your business) will gain by it. If your system is compliant, third party add-on packages (and possibly your own) will integrate smoothly with your system. Your users will, of course, gain all the benefits listed above, and many of your support headaches will be eased. You will benefit from all the discussion and thought that has been put into the FSSTND and avoid many of the pitfalls involved in designing a filesystem structure yourself. If you adhere to the FSSTND, you will also be able to take advantage of various features that the FSSTND was designed around. For example, the FSSTND makes "live" CD-ROMs containing everything except some of the files in the / and /var directories possible. If you write documentation for Linux, the FSSTND makes it much easier to do so, which makes sense to the Linux community. You no longer need to worry about the specific location of lock files on one distribution versus another, nor are you forced to write documentation that is only useful to the users of a specific distribution. The FSSTND is at least partly responsible for the recent explosion of Linux books being published.

If you are a developer, the existence of the FSSTND greatly eases the possibility for potential problems. You can know where important system binaries are found, so you can use them from inside your programs or your shell scripts. Supporting users is also greatly eased, since you don't have to worry about things like the location of these binaries when resolving support issues. If you are the developer of a program that needs to integrate with the rest of the system, the FSSTND ensures that you can be certain of the steps to meet this end. For example, applications such as kermit, which access the serial ports, need to know they can achieve exclusive access to the TTY device. The FSSTND specifies a common method of doing this so that all compliant applications can work together. That way you can concentrate on making more great software for Linux instead of worrying about how to detect and deal with the differences in flavors of Linux. The widespread acceptance of the FSSTND by the Linux community has been crucial to the success of both the standard and operating system. Nearly every modern distribution conforms to the Linux FSSTND. If your implementation isn't at least partially FSSTND compliant, then it is probably either very old or you built it yourself. The FSSTND itself contains a list of some of the distributions that aim to conform to the FSSTND. However, there are some distributions that are known to cut some corners in their implementation of FSSTND.

By no means does this mean that the standard itself is complete. There are still unresolved issues such as the organization of architecture-independent scripts and data files /usr/share. Up until now, the i386 has been the primary platform for Linux, so the need for standardization of such files was non-existent.

The rapid progress in porting Linux to other architectures (MC680x0, Alpha, MIPS, PowerPC) suggests that this issue will soon need to be dealt with. Another issue that is under some discussion is the creation of an /opt directory as in SVR4. The goal for such a directory would be to provide a location for large commercial or third party packages to install themselves without worrying about the requirements made by FSSTND for the other directory hierarchies. The FSSTND provides the Linux community with an excellent reference document and has proven to be an important factor in the maturation of Linux. As Linux continues to evolve, so will the FSSTND.

Now, that we have seen how things should be, let's take a look at the real world. As you will see, the implementation of this concept on Linux isn't perfect and since Linux has always attracted individualists who tend to be fairly opinionated, it has been a bone of contention among users for instance which directories certain files should be put into. With the arrival of different distributions, anarchy has once again descended upon us. Some distributions put mount directories for external media into the / directory, others into /mnt. Red Hat based distributions feature the /etc/sysconfig sub-hierarchy for configuration files concerning input and network devices. Other distributions do not have this directory at all and put the appropriate files elsewhere or even use completely different mechanisms to do the same thing. Some distributions put KDE into /opt/, others into /usr.

But even within a given file system hierarchy, there are inconsistencies. For example, even though this was never the intention of the XFree86 group, XFree86 does indeed have its own directory hierarchy.

These problems don't manifest themselves as long as you compile programs yourself. You can adapt configure scripts or Makefiles to your system's configuration or to your preference. It's a different story if you install pre-compiled packages like RPMs though. Often these are not adaptable from one file system hierarchy to another. What's worse: some RPMs might even create their own hierarchy. If you, say, install a KDE RPM from the SuSE Linux distribution on your Mandrake system, the binary will be put into /opt/kde2/bin. And thus it won't work, because Mandrake expects it to be in /usr/bin. There are of course ways to circumvent this problem but the current situation is clearly untenable. Thus, all the leading Linux distributors have joined the Linux Standard Base project, which is attempting to create a common standard for Linux distributions. This isn't easy, since changing the file system hierarchy means a lot of work for distributors so every distributor tries to push a standard which will allow them to keep as much of their own hierarchy as possible. The LSB will also encompass the proposals made by the Filesystem Hierarchy Standard project (FHS, former FSSTND).

Prev	Home	Next
Linux Filesystem Hierarchy	Up	The Root Directory

			
